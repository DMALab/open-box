

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Autograd mechanics: a RST Example from PyTorch. &mdash; open-box 0.7 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Open-BOX: Generalized and Efficient Blackbox Optimization System." href="../main.html" />
    <link rel="prev" title="Autograd mechanics: a RST Example from PyTorch." href="../notes/note2.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> open-box
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notes/note1.html">Note 1.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/note2.html">Autograd mechanics: a RST Example from PyTorch.</a></li>
</ul>
<p class="caption"><span class="caption-text">Docs Examples</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Autograd mechanics: a RST Example from PyTorch.</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#excluding-subgraphs-from-backward">Excluding subgraphs from backward</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requires-grad"><code class="docutils literal notranslate"><span class="pre">requires_grad</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#how-autograd-encodes-the-history">How autograd encodes the history</a></li>
<li class="toctree-l2"><a class="reference internal" href="#in-place-operations-with-autograd">In-place operations with autograd</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#in-place-correctness-checks">In-place correctness checks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multithreaded-autograd">Multithreaded Autograd</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#concurrency-on-cpu">Concurrency on CPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-determinism">Non-determinism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-retaining">Graph retaining</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thread-safety-on-autograd-node">Thread Safety on Autograd Node</a></li>
<li class="toctree-l3"><a class="reference internal" href="#no-thread-safety-on-c-hooks">No thread safety on C++ hooks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#autograd-for-complex-numbers">Autograd for Complex Numbers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-are-complex-derivatives">What are complex derivatives?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wirtinger-calculus-comes-in-picture">Wirtinger Calculus comes in picture …</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-is-wirtinger-calculus-useful-in-optimization">How is Wirtinger Calculus useful in optimization?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-does-pytorch-compute-the-conjugate-wirtinger-derivative">How does PyTorch compute the conjugate Wirtinger derivative?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-can-i-write-my-own-derivative-formula-for-a-complex-function">How can I write my own derivative formula for a complex function?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-about-cross-domain-functions">What about cross-domain functions?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Summary</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../main.html">Open-BOX: Generalized and Efficient Blackbox Optimization System.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../main.html#deployment-artifacts">Deployment Artifacts</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">open-box</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Autograd mechanics: a RST Example from PyTorch.</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/examples/pytorch_rst_complex_example.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="autograd-mechanics-a-rst-example-from-pytorch">
<span id="autograd-mechanics"></span><h1>Autograd mechanics: a RST Example from PyTorch.<a class="headerlink" href="#autograd-mechanics-a-rst-example-from-pytorch" title="Permalink to this headline">¶</a></h1>
<p>This note will present an overview of how autograd works and records the
operations. It’s not strictly necessary to understand all this, but we recommend
getting familiar with it, as it will help you write more efficient, cleaner
programs, and can aid you in debugging.</p>
<div class="section" id="excluding-subgraphs-from-backward">
<span id="excluding-subgraphs"></span><h2>Excluding subgraphs from backward<a class="headerlink" href="#excluding-subgraphs-from-backward" title="Permalink to this headline">¶</a></h2>
<p>Every Tensor has a flag: <code class="xref py py-attr docutils literal notranslate"><span class="pre">requires_grad</span></code> that allows for fine grained
exclusion of subgraphs from gradient computation and can increase efficiency.</p>
<div class="section" id="requires-grad">
<span id="excluding-requires-grad"></span><h3><code class="docutils literal notranslate"><span class="pre">requires_grad</span></code><a class="headerlink" href="#requires-grad" title="Permalink to this headline">¶</a></h3>
<p>If there’s a single input to an operation that requires gradient, its output
will also require gradient. Conversely, only if all inputs don’t require
gradient, the output also won’t require it. Backward computation is never
performed in the subgraphs, where all Tensors didn’t require gradients.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># requires_grad=False by default</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># requires_grad=False by default</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">requires_grad</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">requires_grad</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is especially useful when you want to freeze part of your model, or you
know in advance that you’re not going to use gradients w.r.t. some parameters.
For example if you want to finetune a pretrained CNN, it’s enough to switch the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">requires_grad</span></code> flags in the frozen base, and no intermediate buffers will
be saved, until the computation gets to the last layer, where the affine
transform will use weights that require gradient, and the output of the network
will also require them.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">resnet18</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
    <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># Replace the last fully-connected layer</span>
<span class="c1"># Parameters of newly constructed modules have requires_grad=True by default</span>
<span class="n">model</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># Optimize only the classifier</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fc</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="how-autograd-encodes-the-history">
<span id="how-autograd-encodes-history"></span><h2>How autograd encodes the history<a class="headerlink" href="#how-autograd-encodes-the-history" title="Permalink to this headline">¶</a></h2>
<p>Autograd is reverse automatic differentiation system.  Conceptually,
autograd records a graph recording all of the operations that created
the data as you execute operations, giving you a directed acyclic graph
whose leaves are the input tensors and roots are the output tensors.
By tracing this graph from roots to leaves, you can automatically
compute the gradients using the chain rule.</p>
<p>Internally, autograd represents this graph as a graph of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> objects (really expressions), which can be
<code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> ed to compute the result of
evaluating the graph.  When computing the forwards pass, autograd
simultaneously performs the requested computations and builds up a graph
representing the function that computes the gradient (the <code class="docutils literal notranslate"><span class="pre">.grad_fn</span></code>
attribute of each <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code> is an entry point into this graph).
When the forwards pass is completed, we evaluate this graph in the
backwards pass to compute the gradients.</p>
<p>An important thing to note is that the graph is recreated from scratch at every
iteration, and this is exactly what allows for using arbitrary Python control
flow statements, that can change the overall shape and size of the graph at
every iteration. You don’t have to encode all possible paths before you
launch the training - what you run is what you differentiate.</p>
</div>
<div class="section" id="in-place-operations-with-autograd">
<h2>In-place operations with autograd<a class="headerlink" href="#in-place-operations-with-autograd" title="Permalink to this headline">¶</a></h2>
<p>Supporting in-place operations in autograd is a hard matter, and we discourage
their use in most cases. Autograd’s aggressive buffer freeing and reuse makes
it very efficient and there are very few occasions when in-place operations
actually lower memory usage by any significant amount. Unless you’re operating
under heavy memory pressure, you might never need to use them.</p>
<p>There are two main reasons that limit the applicability of in-place operations:</p>
<ol class="arabic simple">
<li><p>In-place operations can potentially overwrite values required to compute
gradients.</p></li>
<li><p>Every in-place operation actually requires the implementation to rewrite the
computational graph. Out-of-place versions simply allocate new objects and
keep references to the old graph, while in-place operations, require
changing the creator of all inputs to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> representing
this operation. This can be tricky, especially if there are many Tensors
that reference the same storage (e.g. created by indexing or transposing),
and in-place functions will actually raise an error if the storage of
modified inputs is referenced by any other <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>.</p></li>
</ol>
<div class="section" id="in-place-correctness-checks">
<h3>In-place correctness checks<a class="headerlink" href="#in-place-correctness-checks" title="Permalink to this headline">¶</a></h3>
<p>Every tensor keeps a version counter, that is incremented every time it is
marked dirty in any operation. When a Function saves any tensors for backward,
a version counter of their containing Tensor is saved as well. Once you access
<code class="docutils literal notranslate"><span class="pre">self.saved_tensors</span></code> it is checked, and if it is greater than the saved value
an error is raised. This ensures that if you’re using in-place
functions and not seeing any errors, you can be sure that the computed
gradients are correct.</p>
</div>
</div>
<div class="section" id="multithreaded-autograd">
<h2>Multithreaded Autograd<a class="headerlink" href="#multithreaded-autograd" title="Permalink to this headline">¶</a></h2>
<p>The autograd engine is responsible for running all the backward operations
necessary to compute the backward pass. This section will describe all the details
that can help you make the best use of it in a multithreaded environment.(this is
relevant only for PyTorch 1.6+ as the behavior in previous version was different).</p>
<p>User could train their model with multithreading code (e.g. Hogwild training), and
does not block on the concurrent backward computations, example code could be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a train function to be used in different threads</span>
<span class="k">def</span> <span class="nf">train_fn</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># forward</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="c1"># backward</span>
    <span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="c1"># potential optimizer update</span>


<span class="c1"># User write their own threading code to drive the train_fn</span>
<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">train_fn</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">threads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that some behaviors that user should be aware of:</p>
<div class="section" id="concurrency-on-cpu">
<h3>Concurrency on CPU<a class="headerlink" href="#concurrency-on-cpu" title="Permalink to this headline">¶</a></h3>
<p>When you run <code class="docutils literal notranslate"><span class="pre">backward()</span></code> or <code class="docutils literal notranslate"><span class="pre">grad()</span></code> via python or C++ API in multiple
threads on CPU, you are expecting to see extra concurrency instead of
serializing all the backward calls in a specific order during execution
(behavior before PyTorch 1.6).</p>
</div>
<div class="section" id="non-determinism">
<h3>Non-determinism<a class="headerlink" href="#non-determinism" title="Permalink to this headline">¶</a></h3>
<p>If you are calling <code class="docutils literal notranslate"><span class="pre">backward()</span></code> on multiple thread concurrently but with
shared inputs (i.e. Hogwild CPU training). Since parameters are automatically
shared across threads, gradient accumulation might become non-deterministic on
backward calls across threads, because two backward calls might access and try
to accumulate the same <code class="docutils literal notranslate"><span class="pre">.grad</span></code> attribute. This is technically not safe, and
it might result in racing condition and the result might be invalid to use.</p>
<p>But this is expected pattern if you are using the multithreading approach to
drive the whole training process but using shared parameters, user who use
multithreading should have the threading model in mind and should expect this
to happen. User could use the functional API <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.autograd.grad()</span></code> to
calculate the gradients instead of <code class="docutils literal notranslate"><span class="pre">backward()</span></code> to avoid non-determinism.</p>
</div>
<div class="section" id="graph-retaining">
<h3>Graph retaining<a class="headerlink" href="#graph-retaining" title="Permalink to this headline">¶</a></h3>
<p>If part of the autograd graph is shared between threads, i.e. run first
part of forward single thread, then run second part in multiple threads,
then the first part of graph is shared. In this case different threads
execute <code class="docutils literal notranslate"><span class="pre">grad()</span></code> or <code class="docutils literal notranslate"><span class="pre">backward()</span></code> on the same graph might have issue of
destroying the graph on the fly of one thread, and the other thread will
crash in this case. Autograd will error out to the user similar to what call
<code class="docutils literal notranslate"><span class="pre">backward()</span></code> twice with out <code class="docutils literal notranslate"><span class="pre">retain_graph=True</span></code>, and let the user know
they should use <code class="docutils literal notranslate"><span class="pre">retain_graph=True</span></code>.</p>
</div>
<div class="section" id="thread-safety-on-autograd-node">
<h3>Thread Safety on Autograd Node<a class="headerlink" href="#thread-safety-on-autograd-node" title="Permalink to this headline">¶</a></h3>
<p>Since Autograd allows the caller thread to drive its backward execution for
potential parallelism, it’s important that we ensure thread safety on CPU with
parallel backwards that share part/whole of the GraphTask.</p>
<p>Custom Python <code class="docutils literal notranslate"><span class="pre">autograd.function</span></code> is automatically thread safe because of GIL.
for built-in C++ Autograd Nodes(e.g. AccumulateGrad, CopySlices) and custom
<code class="docutils literal notranslate"><span class="pre">autograd::Function</span></code>, the Autograd Engine uses thread mutex locking to protect
thread safety on autograd Nodes that might have state write/read.</p>
</div>
<div class="section" id="no-thread-safety-on-c-hooks">
<h3>No thread safety on C++ hooks<a class="headerlink" href="#no-thread-safety-on-c-hooks" title="Permalink to this headline">¶</a></h3>
<p>Autograd relies on the user to write thread safe C++ hooks. If you want the hook
to be correctly applied in multithreading environment, you will need to write
proper thread locking code to ensure the hooks are thread safe.</p>
</div>
</div>
<div class="section" id="autograd-for-complex-numbers">
<span id="complex-autograd-doc"></span><h2>Autograd for Complex Numbers<a class="headerlink" href="#autograd-for-complex-numbers" title="Permalink to this headline">¶</a></h2>
<p>The short version:</p>
<ul class="simple">
<li><p>When you use PyTorch to differentiate any function <span class="math notranslate nohighlight">\(f(z)\)</span> with complex domain and/or codomain,
the gradients are computed under the assumption that the function is a part of a larger real-valued
loss function <span class="math notranslate nohighlight">\(g(input)=L\)</span>. The gradient computed is <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial z^*}\)</span>
(note the conjugation of z), the negative of which is precisely the direction of steepest descent
used in Gradient Descent algorithm. Thus, all the existing optimizers work out of
the box with complex parameters.</p></li>
<li><p>This convention matches TensorFlow’s convention for complex
differentiation, but is different from JAX (which computes
<span class="math notranslate nohighlight">\(\frac{\partial L}{\partial z}\)</span>).</p></li>
<li><p>If you have a real-to-real function which internally uses complex
operations, the convention here doesn’t matter: you will always get
the same result that you would have gotten if it had been implemented
with only real operations.</p></li>
</ul>
<p>If you are curious about the mathematical details, or want to know how
to define complex derivatives in PyTorch, read on.</p>
<div class="section" id="what-are-complex-derivatives">
<h3>What are complex derivatives?<a class="headerlink" href="#what-are-complex-derivatives" title="Permalink to this headline">¶</a></h3>
<p>The mathematical definition of complex-differentiability takes the
limit definition of a derivative and generalizes it to operate on
complex numbers. Consider a function <span class="math notranslate nohighlight">\(f: ℂ → ℂ\)</span>,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[`f(z=x+yj) = u(x, y) + v(x, y)j`\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are two variable real valued functions.</p>
<p>Using the derivative definition, we can write:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[f'(z) = \lim_{h \to 0, h \in C} \frac{f(z+h) - f(z)}{h}\]</div>
</div></blockquote>
<p>In order for this limit to exist, not only must <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> must be
real differentiable, but <span class="math notranslate nohighlight">\(f\)</span> must also satisfy the Cauchy-Riemann <a class="reference external" href="https://en.wikipedia.org/wiki/Cauchy%E2%80%93Riemann_equations">equations</a>.  In
other words: the limit computed for real and imaginary steps (<span class="math notranslate nohighlight">\(h\)</span>)
must be equal. This is a more restrictive condition.</p>
<p>The complex differentiable functions are commonly known as holomorphic
functions. They are well behaved, have all the nice properties that
you’ve seen from real differentiable functions, but are practically of no
use in the optimization world. For optimization problems, only real valued objective
functions are used in the research community since complex numbers are not part of any
ordered field and so having complex valued loss does not make much sense.</p>
<p>It also turns out that no interesting real-valued objective fulfill the
Cauchy-Riemann equations. So the theory with homomorphic function cannot be
used for optimization and most people therefore use the Wirtinger calculus.</p>
</div>
<div class="section" id="wirtinger-calculus-comes-in-picture">
<h3>Wirtinger Calculus comes in picture …<a class="headerlink" href="#wirtinger-calculus-comes-in-picture" title="Permalink to this headline">¶</a></h3>
<p>So, we have this great theory of complex differentiability and
holomorphic functions, and we can’t use any of it at all, because many
of the commonly used functions are not holomorphic. What’s a poor
mathematician to do? Well, Wirtinger observed that even if <span class="math notranslate nohighlight">\(f(z)\)</span>
isn’t holomorphic, one could rewrite it as a two variable function
<span class="math notranslate nohighlight">\(f(z, z*)\)</span> which is always holomorphic. This is because real and
imaginary of the components of <span class="math notranslate nohighlight">\(z\)</span> can be expressed in terms of
<span class="math notranslate nohighlight">\(z\)</span> and <span class="math notranslate nohighlight">\(z^*\)</span> as:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    Re(z) &amp;= \frac {z + z^*}{2} \\
    Im(z) &amp;= \frac {z - z^*}{2j}
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>Wirtinger calculus suggests to study <span class="math notranslate nohighlight">\(f(z, z^*)\)</span> instead, which is
guaranteed to be holomorphic if <span class="math notranslate nohighlight">\(f\)</span> was real differentiable (another
way to think of it is as a change of coordinate system, from <span class="math notranslate nohighlight">\(f(x, y)\)</span>
to <span class="math notranslate nohighlight">\(f(z, z^*)\)</span>.)  This function has partial derivatives
<span class="math notranslate nohighlight">\(\frac{\partial }{\partial z}\)</span> and <span class="math notranslate nohighlight">\(\frac{\partial}{\partial z^{*}}\)</span>.
We can use the chain rule to establish a
relationship between these partial derivatives and the partial
derivatives w.r.t., the real and imaginary components of <span class="math notranslate nohighlight">\(z\)</span>.</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \frac{\partial }{\partial x} &amp;= \frac{\partial z}{\partial x} * \frac{\partial }{\partial z} + \frac{\partial z^*}{\partial x} * \frac{\partial }{\partial z^*} \\
                                 &amp;= \frac{\partial }{\partial z} + \frac{\partial }{\partial z^*}   \\
    \\
    \frac{\partial }{\partial y} &amp;= \frac{\partial z}{\partial y} * \frac{\partial }{\partial z} + \frac{\partial z^*}{\partial y} * \frac{\partial }{\partial z^*} \\
                                 &amp;= 1j * (\frac{\partial }{\partial z} - \frac{\partial }{\partial z^*})
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>From the above equations, we get:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \frac{\partial }{\partial z} &amp;= 1/2 * (\frac{\partial }{\partial x} - 1j * \frac{\partial }{\partial y})   \\
    \frac{\partial }{\partial z^*} &amp;= 1/2 * (\frac{\partial }{\partial x} + 1j * \frac{\partial }{\partial y})
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>which is the classic definition of Wirtinger calculus that you would find on <a class="reference external" href="https://en.wikipedia.org/wiki/Wirtinger_derivatives">Wikipedia</a>.</p>
<p>There are a lot of beautiful consequences of this change.</p>
<ul class="simple">
<li><p>For one, the Cauchy-Riemann equations translate into simply saying that <span class="math notranslate nohighlight">\(\frac{\partial f}{\partial z^*} = 0\)</span> (that is to say, the function <span class="math notranslate nohighlight">\(f\)</span> can be written
entirely in terms of <span class="math notranslate nohighlight">\(z\)</span>, without making reference to <span class="math notranslate nohighlight">\(z^*\)</span>).</p></li>
<li><p>Another important (and somewhat counterintuitive) result, as we’ll see later, is that when we do optimization on a real-valued loss, the step we should
take while making variable update is given by <span class="math notranslate nohighlight">\(\frac{\partial Loss}{\partial z^*}\)</span> (not <span class="math notranslate nohighlight">\(\frac{\partial Loss}{\partial z}\)</span>).</p></li>
</ul>
<p>For more reading, check out: <a class="reference external" href="https://arxiv.org/pdf/0906.4835.pdf">https://arxiv.org/pdf/0906.4835.pdf</a></p>
</div>
<div class="section" id="how-is-wirtinger-calculus-useful-in-optimization">
<h3>How is Wirtinger Calculus useful in optimization?<a class="headerlink" href="#how-is-wirtinger-calculus-useful-in-optimization" title="Permalink to this headline">¶</a></h3>
<p>Researchers in audio and other fields, more commonly, use gradient
descent to optimize real valued loss functions with complex variables.
Typically, these people treat the real and imaginary values as separate
channels that can be updated. For a step size <span class="math notranslate nohighlight">\(s/2\)</span> and loss
<span class="math notranslate nohighlight">\(L\)</span>, we can write the following equations in <span class="math notranslate nohighlight">\(ℝ^2\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    x_{n+1} &amp;= x_n - (s/2) * \frac{\partial L}{\partial x}  \\
    y_{n+1} &amp;= y_n - (s/2) * \frac{\partial L}{\partial y}
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>How do these equations translate into complex space <span class="math notranslate nohighlight">\(ℂ\)</span>?</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    z_{n+1} &amp;= x_n - (s/2) * \frac{\partial L}{\partial x} + 1j * (y_n - (s/2) * \frac{\partial L}{\partial y}) \\
            &amp;= z_n - s * 1/2 * (\frac{\partial L}{\partial x} + j \frac{\partial L}{\partial y}) \\
            &amp;= z_n - s * \frac{\partial L}{\partial z^*}
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>Something very interesting has happened: Wirtinger calculus tells us
that we can simplify the complex variable update formula above to only
refer to the conjugate Wirtinger derivative
<span class="math notranslate nohighlight">\(\frac{\partial L}{\partial z^*}\)</span>, giving us exactly the step we take in optimization.</p>
<p>Because the conjugate Wirtinger derivative gives us exactly the correct step for a real valued loss function, PyTorch gives you this derivative
when you differentiate a function with a real valued loss.</p>
</div>
<div class="section" id="how-does-pytorch-compute-the-conjugate-wirtinger-derivative">
<h3>How does PyTorch compute the conjugate Wirtinger derivative?<a class="headerlink" href="#how-does-pytorch-compute-the-conjugate-wirtinger-derivative" title="Permalink to this headline">¶</a></h3>
<p>Typically, our derivative formulas take in <cite>grad_output</cite> as an input,
representing the incoming Vector-Jacobian product that we’ve already
computed, aka, <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial s^*}\)</span>, where <span class="math notranslate nohighlight">\(L\)</span>
is the loss of the entire computation (producing a real loss) and
<span class="math notranslate nohighlight">\(s\)</span> is the output of our function. The goal here is to compute
<span class="math notranslate nohighlight">\(\frac{\partial L}{\partial z^*}\)</span>, where <span class="math notranslate nohighlight">\(z\)</span> is the input of
the function.  It turns out that in the case of real loss, we can
get away with <em>only</em> calculating <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial z^*}\)</span>,
even though the chain rule implies that we also need to
have access to <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial z^*}\)</span>.  If you want
to skip this derivation, look at the last equation in this section
and then skip to the next section.</p>
<p>Let’s continue working with <span class="math notranslate nohighlight">\(f: ℂ → ℂ\)</span> defined as
<span class="math notranslate nohighlight">\(f(z) = f(x+yj) = u(x, y) + v(x, y)j\)</span>. As discussed above,
autograd’s gradient convention is centered around optimization for real
valued loss functions, so let’s assume <span class="math notranslate nohighlight">\(f\)</span> is a part of larger
real valued loss function <span class="math notranslate nohighlight">\(g\)</span>. Using chain rule, we can write:</p>
<blockquote>
<div><div class="math notranslate nohighlight" id="equation-1">
<span class="eqno">(1)<a class="headerlink" href="#equation-1" title="Permalink to this equation">¶</a></span>\[\frac{\partial L}{\partial z^*} = \frac{\partial L}{\partial u} * \frac{\partial u}{\partial z^*} + \frac{\partial L}{\partial v} * \frac{\partial v}{\partial z^*}\]</div>
</div></blockquote>
<p>Now using Wirtinger derivative definition, we can write:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \frac{\partial L}{\partial s} = 1/2 * (\frac{\partial L}{\partial u} - \frac{\partial L}{\partial v} j) \\
    \frac{\partial L}{\partial s^*} = 1/2 * (\frac{\partial L}{\partial u} + \frac{\partial L}{\partial v} j)
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>It should be noted here that since <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are real
functions, and <span class="math notranslate nohighlight">\(L\)</span> is real by our assumption that <span class="math notranslate nohighlight">\(f\)</span> is a
part of a real valued function, we have:</p>
<blockquote>
<div><div class="math notranslate nohighlight" id="equation-2">
<span class="eqno">(2)<a class="headerlink" href="#equation-2" title="Permalink to this equation">¶</a></span>\[(\frac{\partial L}{\partial s})^* = \frac{\partial L}{\partial s^*}\]</div>
</div></blockquote>
<p>i.e., <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial s}\)</span> equals to <span class="math notranslate nohighlight">\(grad\_output^*\)</span>.</p>
<p>Solving the above equations for <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial u}\)</span> and <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial v}\)</span>, we get:</p>
<blockquote>
<div><div class="math notranslate nohighlight" id="equation-3">
<span class="eqno">(3)<a class="headerlink" href="#equation-3" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{aligned}
    \frac{\partial L}{\partial u} = \frac{\partial L}{\partial s} + \frac{\partial L}{\partial s^*} \\
    \frac{\partial L}{\partial v} = -1j * (\frac{\partial L}{\partial s} - \frac{\partial L}{\partial s^*})
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>Substituting <a class="reference internal" href="#equation-3">(3)</a> in <a class="reference internal" href="#equation-1">(1)</a>, we get:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \frac{\partial L}{\partial z^*} &amp;= (\frac{\partial L}{\partial s} + \frac{\partial L}{\partial s^*}) * \frac{\partial u}{\partial z^*} - 1j * (\frac{\partial L}{\partial s} - \frac{\partial L}{\partial s^*}) * \frac{\partial v}{\partial z^*}  \\
                                    &amp;= \frac{\partial L}{\partial s} * (\frac{\partial u}{\partial z^*} + \frac{\partial v}{\partial z^*} j) + \frac{\partial L}{\partial s^*} * (\frac{\partial u}{\partial z^*} - \frac{\partial v}{\partial z^*} j)  \\
                                    &amp;= \frac{\partial L}{\partial s^*} * \frac{\partial (u + vj)}{\partial z^*} + \frac{\partial L}{\partial s} * \frac{\partial (u + vj)^*}{\partial z^*}  \\
                                    &amp;= \frac{\partial L}{\partial s} * \frac{\partial s}{\partial z^*} + \frac{\partial L}{\partial s^*} * \frac{\partial s^*}{\partial z^*}    \\
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>Using <a class="reference internal" href="#equation-2">(2)</a>, we get:</p>
<blockquote>
<div><div class="math notranslate nohighlight" id="equation-4">
<span class="eqno">(4)<a class="headerlink" href="#equation-4" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{aligned}
    \frac{\partial L}{\partial z^*} &amp;= (\frac{\partial L}{\partial s^*})^* * \frac{\partial s}{\partial z^*} + \frac{\partial L}{\partial s^*} * (\frac{\partial s}{\partial z})^*  \\
                                    &amp;= \boxed{ (grad\_output)^* * \frac{\partial s}{\partial z^*} + grad\_output * {(\frac{\partial s}{\partial z})}^* }       \\
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>This last equation is the important one for writing your own gradients,
as it decomposes our derivative formula into a simpler one that is easy
to compute by hand.</p>
</div>
<div class="section" id="how-can-i-write-my-own-derivative-formula-for-a-complex-function">
<h3>How can I write my own derivative formula for a complex function?<a class="headerlink" href="#how-can-i-write-my-own-derivative-formula-for-a-complex-function" title="Permalink to this headline">¶</a></h3>
<p>The above boxed equation gives us the general formula for all
derivatives on complex functions.  However, we still need to
compute <span class="math notranslate nohighlight">\(\frac{\partial s}{\partial z}\)</span> and <span class="math notranslate nohighlight">\(\frac{\partial s}{\partial z^*}\)</span>.
There are two ways you could do this:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first way is to just use the definition of Wirtinger derivatives directly and calculate <span class="math notranslate nohighlight">\(\frac{\partial s}{\partial z}\)</span> and <span class="math notranslate nohighlight">\(\frac{\partial s}{\partial z^*}\)</span> by
using <span class="math notranslate nohighlight">\(\frac{\partial s}{\partial x}\)</span> and <span class="math notranslate nohighlight">\(\frac{\partial s}{\partial y}\)</span>
(which you can compute in the normal way).</p></li>
<li><p>The second way is to use the change of variables trick and rewrite <span class="math notranslate nohighlight">\(f(z)\)</span> as a two variable function <span class="math notranslate nohighlight">\(f(z, z^*)\)</span>, and compute
the conjugate Wirtinger derivatives by treating <span class="math notranslate nohighlight">\(z\)</span> and <span class="math notranslate nohighlight">\(z^*\)</span> as independent variables. This is often easier; for example, if the function in question is holomorphic, only <span class="math notranslate nohighlight">\(z\)</span> will be used (and <span class="math notranslate nohighlight">\(\frac{\partial s}{\partial z^*}\)</span> will be zero).</p></li>
</ul>
</div></blockquote>
<p>Let’s consider the function <span class="math notranslate nohighlight">\(f(z = x + yj) = c * z = c * (x+yj)\)</span> as an example, where <span class="math notranslate nohighlight">\(c \in ℝ\)</span>.</p>
<p>Using the first way to compute the Wirtinger derivatives, we have.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \frac{\partial s}{\partial z} &amp;= 1/2 * (\frac{\partial s}{\partial x} - \frac{\partial s}{\partial y} j) \\
                                  &amp;= 1/2 * (c - (c * 1j) * 1j)  \\
                                  &amp;= c                          \\
    \\
    \\
    \frac{\partial s}{\partial z^*} &amp;= 1/2 * (\frac{\partial s}{\partial x} + \frac{\partial s}{\partial y} j) \\
                                    &amp;= 1/2 * (c + (c * 1j) * 1j)  \\
                                    &amp;= 0                          \\
\end{aligned}\end{split}\]</div>
<p>Using <a class="reference internal" href="#equation-4">(4)</a>, and <cite>grad_output = 1.0</cite> (which is the default grad output value used when <code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code> is called on a scalar output in PyTorch), we get:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{\partial L}{\partial z^*} = 1 * 0 + 1 * c = c\]</div>
</div></blockquote>
<p>Using the second way to compute Wirtinger derivatives, we directly get:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
   \frac{\partial s}{\partial z} &amp;= \frac{\partial (c*z)}{\partial z}       \\
                                 &amp;= c                                       \\
    \frac{\partial s}{\partial z^*} &amp;= \frac{\partial (c*z)}{\partial z^*}       \\
                                 &amp;= 0
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>And using <a class="reference internal" href="#equation-4">(4)</a> again, we get <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial z^*} = c\)</span>. As you can see, the second way involves lesser calculations, and comes
in more handy for faster calculations.</p>
</div>
<div class="section" id="what-about-cross-domain-functions">
<h3>What about cross-domain functions?<a class="headerlink" href="#what-about-cross-domain-functions" title="Permalink to this headline">¶</a></h3>
<p>Some functions map from complex inputs to real outputs, or vice versa.
These functions form a special case of <a class="reference internal" href="#equation-4">(4)</a>, which we can derive using the
chain rule:</p>
<blockquote>
<div><ul>
<li><p>For <span class="math notranslate nohighlight">\(f: ℂ → ℝ\)</span>, we get:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{\partial L}{\partial z^*} = 2 * grad\_output * \frac{\partial s}{\partial z^{*}}\]</div>
</div></blockquote>
</li>
<li><p>For <span class="math notranslate nohighlight">\(f: ℝ → ℂ\)</span>, we get:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{\partial L}{\partial z^*} = 2 * Re(grad\_out^* * \frac{\partial s}{\partial z^{*}})\]</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../main.html" class="btn btn-neutral float-right" title="Open-BOX: Generalized and Efficient Blackbox Optimization System." accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../notes/note2.html" class="btn btn-neutral float-left" title="Autograd mechanics: a RST Example from PyTorch." accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Thomas (Yang) Li.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>